<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Assistente Virtual por Áudio</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --color-background: #18181b;
        --color-surface: #27272a;
        --color-text: #e4e4e7;
        --color-text-secondary: #a1a1aa;
        --color-border: rgba(255, 255, 255, 0.15);
        --color-card-border: rgba(255, 255, 255, 0.2);
        --color-primary: #2dd4bf;
        --color-primary-hover: #14b8a6;
        --color-disabled: #3f3f46;
        --color-enabled: #4caf50;
        --color-recording: #f44336;
        --color-speaking: #2196f3;
        --color-error: #f43f5e;
        --color-error-bg: rgba(244, 63, 94, 0.15);
        --color-info-bg: rgba(45, 212, 191, 0.1);

        --font-family-base:
          "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        --font-size-base: 14px;
        --font-size-sm: 12px;
        --font-size-lg: 16px;
        --font-size-xl: 18px;
        --font-weight-medium: 500;
        --font-weight-semibold: 600;

        --space-8: 8px;
        --space-12: 12px;
        --space-16: 16px;
        --space-24: 24px;
        --space-32: 32px;

        --radius-base: 8px;
        --radius-lg: 12px;
        --radius-full: 9999px;

        --shadow-sm:
          0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
        --shadow-lg:
          0 10px 15px -3px rgba(0, 0, 0, 0.04),
          0 4px 6px -2px rgba(0, 0, 0, 0.02);
        --duration-normal: 250ms;
        --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);
      }

      html {
        font-family: var(--font-family-base);
        color: var(--color-text);
        background-color: var(--color-background);
        -webkit-font-smoothing: antialiased;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: var(--space-16);
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
      }

      *,
      *::before,
      *::after {
        box-sizing: inherit;
      }

      .chat-interface {
        width: 100%;
        max-width: 500px;
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        border: 1px solid var(--color-card-border);
        box-shadow: var(--shadow-lg);
        overflow: hidden;
      }

      .header {
        padding: var(--space-24);
        text-align: center;
        border-bottom: 1px solid var(--color-card-border);
      }

      .header h1 {
        font-size: var(--font-size-xl);
        font-weight: var(--font-weight-semibold);
        margin: 0;
      }

      .main-content {
        padding: var(--space-32);
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--space-24);
      }

      .speaking-animation {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 4px;
        height: 60px;
      }

      .wave {
        width: 4px;
        background: var(--color-speaking);
        border-radius: var(--radius-full);
        animation: waveAnimation 1.5s ease-in-out infinite;
      }

      .wave:nth-child(1) {
        animation-delay: 0s;
        height: 20px;
      }
      .wave:nth-child(2) {
        animation-delay: 0.2s;
        height: 30px;
      }
      .wave:nth-child(3) {
        animation-delay: 0.4s;
        height: 40px;
      }
      .wave:nth-child(4) {
        animation-delay: 0.6s;
        height: 25px;
      }

      @keyframes waveAnimation {
        0%,
        40%,
        100% {
          transform: scaleY(0.4);
        }
        20% {
          transform: scaleY(1);
        }
      }

      .microphone-btn {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        transition: all var(--duration-normal) var(--ease-standard);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .microphone-btn:disabled {
        background-color: var(--color-disabled);
        cursor: not-allowed;
      }

      .microphone-btn.enabled {
        background-color: var(--color-enabled);
        box-shadow: var(--shadow-sm);
      }

      .microphone-btn.enabled:hover {
        transform: scale(1.05);
        box-shadow: var(--shadow-lg);
      }

      .microphone-btn.recording {
        background-color: var(--color-recording);
        animation: pulseRecording 1.5s ease-in-out infinite;
      }

      @keyframes pulseRecording {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .mic-icon {
        width: 32px;
        height: 32px;
        color: white;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
      }

      .webhook-container {
        width: 100%;
        text-align: left;
      }

      .form-label {
        display: block;
        margin-bottom: var(--space-8);
        font-weight: var(--font-weight-medium);
        font-size: var(--font-size-sm);
      }

      .form-control {
        display: block;
        width: 100%;
        padding: var(--space-8) var(--space-12);
        font-size: var(--font-size-base);
        color: var(--color-text);
        background-color: var(--color-surface);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-base);
        transition:
          border-color var(--duration-normal) var(--ease-standard),
          box-shadow var(--duration-normal) var(--ease-standard);
      }

      .form-control:focus {
        border-color: var(--color-primary);
        outline: 0;
        box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.3);
      }

      .status-indicator {
        padding: var(--space-12);
        border-radius: var(--radius-base);
        font-weight: var(--font-weight-medium);
        font-size: var(--font-size-sm);
        text-align: center;
        width: 100%;
      }

      .status-indicator.info {
        background-color: var(--color-info-bg);
        color: var(--color-primary);
      }
      .status-indicator.error {
        background-color: var(--color-error-bg);
        color: var(--color-error);
      }

      .hint {
        width: 100%;
        text-align: left;
        font-size: var(--font-size-sm);
        color: var(--color-text-secondary);
        line-height: 1.4;
      }

      code {
        background: rgba(255, 255, 255, 0.08);
        padding: 2px 6px;
        border-radius: 6px;
        font-size: 12px;
      }
    </style>
  </head>

  <body>
    <div class="chat-interface">
      <div class="header">
        <h1>Assistente Virtual por Áudio</h1>
      </div>

      <div class="main-content">
        <div
          class="speaking-animation"
          id="speakingAnimation"
          style="display: none"
        >
          <div class="wave"></div>
          <div class="wave"></div>
          <div class="wave"></div>
          <div class="wave"></div>
        </div>

        <button class="microphone-btn" id="microphoneBtn" disabled>
          <svg class="mic-icon" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z"
            ></path>
            <path d="M19 10v1a7 7 0 0 1-14 0v-1"></path>
            <line x1="12" y1="19" x2="12" y2="23"></line>
            <line x1="8" y1="23" x2="16" y2="23"></line>
          </svg>
        </button>

        <div class="hint">
          Backend fixo:
          <br />POST:
          <code>https://n8n.oficinahub.xyz/webhook/speakwebpost</code>
          <br />GET:
          <code
            >https://n8n.oficinahub.xyz/webhook/speakwebget?id=&lt;id&gt;</code
          >
        </div>

        <div class="status-indicator info" id="statusIndicator">
          <span id="statusText">Aguardando...</span>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const POST_URL = "https://n8n.oficinahub.xyz/webhook/speakwebpost";
        const GET_URL_BASE = "https://n8n.oficinahub.xyz/webhook/speakwebget";

        if (
          !navigator.mediaDevices ||
          !navigator.mediaDevices.getUserMedia ||
          !window.MediaRecorder
        ) {
          const statusText = document.getElementById("statusText");
          const indicator = document.getElementById("statusIndicator");
          if (statusText)
            statusText.textContent =
              "Erro: Seu navegador não suporta gravação de áudio.";
          if (indicator) indicator.className = "status-indicator error";
          return;
        }

        const microphoneBtn = document.getElementById("microphoneBtn");
        const statusText = document.getElementById("statusText");
        const statusIndicator = document.getElementById("statusIndicator");
        const speakingAnimation = document.getElementById("speakingAnimation");

        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let responseAudio = new Audio();

        function updateStatus(message, type = "info") {
          if (statusText) statusText.textContent = message;
          if (statusIndicator)
            statusIndicator.className = `status-indicator ${type}`;
        }

        function sleep(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms)); // delay via setTimeout [web:12]
        }

        function blobToBase64(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              const base64Data = reader.result.split(",")[1];
              resolve(base64Data);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }

        async function playFromGetUrl(getUrl) {
          updateStatus("Tocando resposta...", "info");
          if (speakingAnimation) speakingAnimation.style.display = "flex";

          const a = new Audio();
          a.preload = "auto";
          a.src = getUrl; // URL normal, não blob

          a.onended = () => {
            updateStatus("Pronto para gravar.", "info");
            if (speakingAnimation) speakingAnimation.style.display = "none";
          };

          a.onerror = () => {
            updateStatus("Erro ao tocar áudio (falha no player).", "error");
            if (speakingAnimation) speakingAnimation.style.display = "none";
          };

          try {
            await a.play(); // play() retorna Promise e pode falhar se não houver gesto do usuário [web:105]
          } catch (e) {
            console.error("Falha ao dar play:", e);
            updateStatus(
              "Erro ao tocar áudio (autoplay bloqueado ou erro no arquivo).",
              "error",
            );
            if (speakingAnimation) speakingAnimation.style.display = "none";
          }
        }

        async function fetchMp3WithRetries(
          getUrl,
          controller,
          tries = 15,
          delayMs = 2000,
        ) {
          let lastStatus = null;
          let lastText = "";

          for (let attempt = 1; attempt <= tries; attempt++) {
            updateStatus(
              `Buscando áudio (GET)... tentativa ${attempt}/${tries}`,
              "info",
            );

            const res = await fetch(getUrl, {
              method: "GET",
              cache: "no-store",
              signal: controller.signal,
            });

            if (res.ok) {
              const contentType = res.headers.get("content-type") || "";
              console.log("[Front] GET Content-Type:", contentType);

              const buf = await res.arrayBuffer();
              console.log("[Front] GET bytes:", buf.byteLength);

              return new Blob([buf], { type: "audio/mpeg" });
            }

            lastStatus = res.status;
            lastText = await res.text().catch(() => "");

            // 404/409 = "ainda não pronto" (você pode manter esse contrato no n8n)
            if (res.status !== 404 && res.status !== 409) {
              throw new Error(
                `GET falhou: ${res.status} ${res.statusText} ${lastText}`,
              );
            }

            await sleep(delayMs);
          }

          throw new Error(
            `Não consegui obter o MP3 após ${tries} tentativas. Último status: ${lastStatus}. ${lastText}`,
          );
        }

        async function sendAudioToBackend(audioBlob) {
          let base64Audio;

          try {
            updateStatus("Convertendo áudio...", "info");
            base64Audio = await blobToBase64(audioBlob);
            console.log("[Front] Áudio convertido para Base64");
          } catch (err) {
            console.error("[Front] Erro ao converter áudio:", err);
            updateStatus("Erro ao converter áudio.", "error");
            return;
          }

          const payload = { base64: base64Audio };

          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
            updateStatus("Erro: Timeout geral do processo.", "error");
          }, 120000);

          try {
            updateStatus("Enviando para o backend (POST)...", "info");
            console.log("[Front] POST =>", POST_URL);

            const postRes = await fetch(POST_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
              signal: controller.signal,
            });

            const postText = await postRes.text().catch(() => "");
            console.log(
              "[Front] POST status:",
              postRes.status,
              postRes.statusText,
            );
            console.log("[Front] POST body:", postText);

            if (!postRes.ok) {
              throw new Error(
                `POST falhou: ${postRes.status} ${postRes.statusText} ${postText}`,
              );
            }

            let id = null;
            try {
              const data = postText ? JSON.parse(postText) : null;
              id = data && data.id;
            } catch (_) {}

            if (!id) {
              throw new Error('POST não retornou JSON com { "id": "..." }.');
            }

            updateStatus("ID recebido. Aguardando 5s...", "info");
            await sleep(5000);

            const getUrl = `${GET_URL_BASE}?id=${encodeURIComponent(id)}`;
            console.log("[Front] GET =>", getUrl);

            const mp3Blob = await fetchMp3WithRetries(
              getUrl,
              controller,
              15,
              2000,
            );

            clearTimeout(timeoutId);
            playResponseAudio(mp3Blob);
          } catch (err) {
            clearTimeout(timeoutId);
            if (err && err.name === "AbortError") return;
            console.error("[Front] Erro ao enviar/baixar áudio:", err);
            updateStatus(
              `Erro: ${err.message || "Falha ao contatar o backend."}`,
              "error",
            );
          }
        }

        async function startRecording() {
          if (isRecording) return;

          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: true,
            });
            isRecording = true;
            audioChunks = [];

            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
              audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
              isRecording = false;

              if (microphoneBtn) {
                microphoneBtn.classList.remove("recording");
                microphoneBtn.classList.add("enabled");
              }

              const audioBlob = new Blob(audioChunks, { type: "audio/webm" });

              updateStatus("Processando...", "info");
              sendAudioToBackend(audioBlob).finally(() =>
                stream.getTracks().forEach((track) => track.stop()),
              );
            };

            mediaRecorder.start();

            if (microphoneBtn) {
              microphoneBtn.classList.remove("enabled");
              microphoneBtn.classList.add("recording");
            }

            updateStatus("Gravando... Clique para parar.", "info");
          } catch (err) {
            console.error("Erro ao acessar microfone:", err);
            updateStatus("Erro: Permissão ao microfone negada.", "error");
            isRecording = false;
          }
        }

        function stopRecording() {
          if (!isRecording || !mediaRecorder) return;
          mediaRecorder.stop();
        }

        if (microphoneBtn) {
          microphoneBtn.disabled = false;
          microphoneBtn.classList.add("enabled");
          updateStatus("Pronto para gravar.", "info");

          microphoneBtn.addEventListener("click", () => {
            if (isRecording) stopRecording();
            else startRecording();
          });
        }
      });
    </script>
  </body>
</html>
